{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/roughjs/bin/geometry.js","../../node_modules/roughjs/bin/fillers/scan-line-hachure.js","../../node_modules/roughjs/bin/fillers/hachure-filler.js","../../node_modules/roughjs/bin/fillers/zigzag-filler.js","../../node_modules/roughjs/bin/fillers/hatch-filler.js","../../node_modules/roughjs/bin/fillers/dot-filler.js","../../node_modules/roughjs/bin/fillers/dashed-filler.js","../../node_modules/roughjs/bin/fillers/zigzag-line-filler.js","../../node_modules/roughjs/bin/fillers/filler.js","../../node_modules/roughjs/bin/math.js","../../node_modules/path-data-parser/lib/parser.js","../../node_modules/path-data-parser/lib/absolutize.js","../../node_modules/path-data-parser/lib/normalize.js","../../node_modules/roughjs/bin/renderer.js","../../node_modules/points-on-curve/lib/curve-to-bezier.js","../../node_modules/points-on-curve/lib/index.js","../../node_modules/roughjs/bin/generator.js","../../node_modules/points-on-path/lib/index.js","../../node_modules/roughjs/bin/canvas.js","../../node_modules/roughjs/bin/core.js","../../node_modules/roughjs/bin/svg.js","../../node_modules/roughjs/bin/rough.js","../../node_modules/nanoid/index.browser.js","../../src/Menu.svelte","../../src/MenuCreate.svelte","../../src/MenuEdit.svelte","../../src/Object.svelte","../../src/guides.js","../../src/selector.js","../../src/DiagramEditor.svelte","../../src/Icon.svelte","../../src/Dialog.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { stylesheet } = info;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            info.rules = {};\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true && boolean_attributes.has(name) ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${style_object[key]};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.46.4' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","export function rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        points.forEach((p) => {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        });\n    }\n}\nexport function rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nexport function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\n","import { rotatePoints, rotateLines } from '../geometry';\nexport function polygonHachureLines(polygonList, o) {\n    const angle = o.hachureAngle + 90;\n    let gap = o.hachureGap;\n    if (gap < 0) {\n        gap = o.strokeWidth * 4;\n    }\n    gap = Math.max(gap, 0.1);\n    const rotationCenter = [0, 0];\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, angle);\n        }\n    }\n    const lines = straightHachureLines(polygonList, gap);\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, -angle);\n        }\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(polygonList, gap) {\n    const vertexArray = [];\n    for (const polygon of polygonList) {\n        const vertices = [...polygon];\n        if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {\n            vertices.push([vertices[0][0], vertices[0][1]]);\n        }\n        if (vertices.length > 2) {\n            vertexArray.push(vertices);\n        }\n    }\n    const lines = [];\n    gap = Math.max(gap, 0.1);\n    // Create sorted edges table\n    const edges = [];\n    for (const vertices of vertexArray) {\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1]),\n                });\n            }\n        }\n    }\n    edges.sort((e1, e2) => {\n        if (e1.ymin < e2.ymin) {\n            return -1;\n        }\n        if (e1.ymin > e2.ymin) {\n            return 1;\n        }\n        if (e1.x < e2.x) {\n            return -1;\n        }\n        if (e1.x > e2.x) {\n            return 1;\n        }\n        if (e1.ymax === e2.ymax) {\n            return 0;\n        }\n        return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n    });\n    if (!edges.length) {\n        return lines;\n    }\n    // Start scanning\n    let activeEdges = [];\n    let y = edges[0].ymin;\n    while (activeEdges.length || edges.length) {\n        if (edges.length) {\n            let ix = -1;\n            for (let i = 0; i < edges.length; i++) {\n                if (edges[i].ymin > y) {\n                    break;\n                }\n                ix = i;\n            }\n            const removed = edges.splice(0, ix + 1);\n            removed.forEach((edge) => {\n                activeEdges.push({ s: y, edge });\n            });\n        }\n        activeEdges = activeEdges.filter((ae) => {\n            if (ae.edge.ymax <= y) {\n                return false;\n            }\n            return true;\n        });\n        activeEdges.sort((ae1, ae2) => {\n            if (ae1.edge.x === ae2.edge.x) {\n                return 0;\n            }\n            return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n        });\n        // fill between the edges\n        if (activeEdges.length > 1) {\n            for (let i = 0; i < activeEdges.length; i = i + 2) {\n                const nexti = i + 1;\n                if (nexti >= activeEdges.length) {\n                    break;\n                }\n                const ce = activeEdges[i].edge;\n                const ne = activeEdges[nexti].edge;\n                lines.push([\n                    [Math.round(ce.x), y],\n                    [Math.round(ne.x), y],\n                ]);\n            }\n        }\n        y += gap;\n        activeEdges.forEach((ae) => {\n            ae.edge.x = ae.edge.x + (gap * ae.edge.islope);\n        });\n    }\n    return lines;\n}\n","import { polygonHachureLines } from './scan-line-hachure';\nexport class HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        return this._fillPolygons(polygonList, o);\n    }\n    _fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        const ops = this.renderLines(lines, o);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o) {\n        const ops = [];\n        for (const line of lines) {\n            ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n        }\n        return ops;\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nimport { polygonHachureLines } from './scan-line-hachure';\nimport { lineLength } from '../geometry';\nexport class ZigZagFiller extends HachureFiller {\n    fillPolygons(polygonList, o) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const o2 = Object.assign({}, o, { hachureGap: gap });\n        const lines = polygonHachureLines(polygonList, o2);\n        const zigZagAngle = (Math.PI / 180) * o.hachureAngle;\n        const zigzagLines = [];\n        const dgx = gap * 0.5 * Math.cos(zigZagAngle);\n        const dgy = gap * 0.5 * Math.sin(zigZagAngle);\n        for (const [p1, p2] of lines) {\n            if (lineLength([p1, p2])) {\n                zigzagLines.push([\n                    [p1[0] - dgx, p1[1] + dgy],\n                    [...p2],\n                ], [\n                    [p1[0] + dgx, p1[1] - dgy],\n                    [...p2],\n                ]);\n            }\n        }\n        const ops = this.renderLines(zigzagLines, o);\n        return { type: 'fillSketch', ops };\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class HatchFiller extends HachureFiller {\n    fillPolygons(polygonList, o) {\n        const set = this._fillPolygons(polygonList, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygons(polygonList, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n","import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        o = Object.assign({}, o, { hachureAngle: 0 });\n        const lines = polygonHachureLines(polygonList, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        const ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const ro = gap / 4;\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const offset = length - (count * gap);\n            const x = ((line[0][0] + line[1][0]) / 2) - (gap / 4);\n            const minY = Math.min(line[0][1], line[1][1]);\n            for (let i = 0; i < count; i++) {\n                const y = minY + offset + (i * gap);\n                const cx = (x - ro) + Math.random() * 2 * ro;\n                const cy = (y - ro) + Math.random() * 2 * ro;\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops.push(...el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n","import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n","import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nimport { ZigZagFiller } from './zigzag-filler';\nimport { HatchFiller } from './hatch-filler';\nimport { DotFiller } from './dot-filler';\nimport { DashedFiller } from './dashed-filler';\nimport { ZigZagLineFiller } from './zigzag-line-filler';\nconst fillers = {};\nexport function getFiller(o, helper) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagFiller(helper);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HatchFiller(helper);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DotFiller(helper);\n                }\n                break;\n            case 'dashed':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DashedFiller(helper);\n                }\n                break;\n            case 'zigzag-line':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagLineFiller(helper);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HachureFiller(helper);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n","export function randomSeed() {\n    return Math.floor(Math.random() * 2 ** 31);\n}\nexport class Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        if (this.seed) {\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\n        }\n        else {\n            return Math.random();\n        }\n    }\n}\n","const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nexport function parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nexport function serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n","// Translate relative commands to absolute commands\nexport function absolutize(segments) {\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    const out = [];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'm':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'M', data: [cx, cy] });\n                subx = cx;\n                suby = cy;\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'l':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                break;\n            case 'c': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'C', data: newdata });\n                cx = newdata[4];\n                cy = newdata[5];\n                break;\n            }\n            case 'Q':\n                out.push({ key: 'Q', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 'q': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'Q', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'A':\n                out.push({ key: 'A', data: [...data] });\n                cx = data[5];\n                cy = data[6];\n                break;\n            case 'a':\n                cx += data[5];\n                cy += data[6];\n                out.push({ key: 'A', data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });\n                break;\n            case 'H':\n                out.push({ key: 'H', data: [...data] });\n                cx = data[0];\n                break;\n            case 'h':\n                cx += data[0];\n                out.push({ key: 'H', data: [cx] });\n                break;\n            case 'V':\n                out.push({ key: 'V', data: [...data] });\n                cy = data[0];\n                break;\n            case 'v':\n                cy += data[0];\n                out.push({ key: 'V', data: [cy] });\n                break;\n            case 'S':\n                out.push({ key: 'S', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 's': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'S', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'T':\n                out.push({ key: 'T', data: [...data] });\n                cx = data[0];\n                cy = data[1];\n                break;\n            case 't':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'T', data: [cx, cy] });\n                break;\n            case 'Z':\n            case 'z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n    }\n    return out;\n}\n","// Normalize path to include only M, L, C, and Z commands\nexport function normalize(segments) {\n    const out = [];\n    let lastType = '';\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    let lcx = 0, lcy = 0;\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                lcx = data[2];\n                lcy = data[3];\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'H':\n                cx = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'V':\n                cy = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'S': {\n                let cx1 = 0, cy1 = 0;\n                if (lastType === 'C' || lastType === 'S') {\n                    cx1 = cx + (cx - lcx);\n                    cy1 = cy + (cy - lcy);\n                }\n                else {\n                    cx1 = cx;\n                    cy1 = cy;\n                }\n                out.push({ key: 'C', data: [cx1, cy1, ...data] });\n                lcx = data[0];\n                lcy = data[1];\n                cx = data[2];\n                cy = data[3];\n                break;\n            }\n            case 'T': {\n                const [x, y] = data;\n                let x1 = 0, y1 = 0;\n                if (lastType === 'Q' || lastType === 'T') {\n                    x1 = cx + (cx - lcx);\n                    y1 = cy + (cy - lcy);\n                }\n                else {\n                    x1 = cx;\n                    y1 = cy;\n                }\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'Q': {\n                const [x1, y1, x, y] = data;\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'A': {\n                const r1 = Math.abs(data[0]);\n                const r2 = Math.abs(data[1]);\n                const angle = data[2];\n                const largeArcFlag = data[3];\n                const sweepFlag = data[4];\n                const x = data[5];\n                const y = data[6];\n                if (r1 === 0 || r2 === 0) {\n                    out.push({ key: 'C', data: [cx, cy, x, y, x, y] });\n                    cx = x;\n                    cy = y;\n                }\n                else {\n                    if (cx !== x || cy !== y) {\n                        const curves = arcToCubicCurves(cx, cy, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n                        curves.forEach(function (curve) {\n                            out.push({ key: 'C', data: curve });\n                        });\n                        cx = x;\n                        cy = y;\n                    }\n                }\n                break;\n            }\n            case 'Z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n        lastType = key;\n    }\n    return out;\n}\nfunction degToRad(degrees) {\n    return (Math.PI * degrees) / 180;\n}\nfunction rotate(x, y, angleRad) {\n    const X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n    const Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n    return [X, Y];\n}\nfunction arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, recursive) {\n    const angleRad = degToRad(angle);\n    let params = [];\n    let f1 = 0, f2 = 0, cx = 0, cy = 0;\n    if (recursive) {\n        [f1, f2, cx, cy] = recursive;\n    }\n    else {\n        [x1, y1] = rotate(x1, y1, -angleRad);\n        [x2, y2] = rotate(x2, y2, -angleRad);\n        const x = (x1 - x2) / 2;\n        const y = (y1 - y2) / 2;\n        let h = (x * x) / (r1 * r1) + (y * y) / (r2 * r2);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            r1 = h * r1;\n            r2 = h * r2;\n        }\n        const sign = (largeArcFlag === sweepFlag) ? -1 : 1;\n        const r1Pow = r1 * r1;\n        const r2Pow = r2 * r2;\n        const left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n        const right = r1Pow * y * y + r2Pow * x * x;\n        const k = sign * Math.sqrt(Math.abs(left / right));\n        cx = k * r1 * y / r2 + (x1 + x2) / 2;\n        cy = k * -r2 * x / r1 + (y1 + y2) / 2;\n        f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));\n        f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));\n        if (x1 < cx) {\n            f1 = Math.PI - f1;\n        }\n        if (x2 < cx) {\n            f2 = Math.PI - f2;\n        }\n        if (f1 < 0) {\n            f1 = Math.PI * 2 + f1;\n        }\n        if (f2 < 0) {\n            f2 = Math.PI * 2 + f2;\n        }\n        if (sweepFlag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweepFlag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    }\n    let df = f2 - f1;\n    if (Math.abs(df) > (Math.PI * 120 / 180)) {\n        const f2old = f2;\n        const x2old = x2;\n        const y2old = y2;\n        if (sweepFlag && f2 > f1) {\n            f2 = f1 + (Math.PI * 120 / 180) * (1);\n        }\n        else {\n            f2 = f1 + (Math.PI * 120 / 180) * (-1);\n        }\n        x2 = cx + r1 * Math.cos(f2);\n        y2 = cy + r2 * Math.sin(f2);\n        params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    const c1 = Math.cos(f1);\n    const s1 = Math.sin(f1);\n    const c2 = Math.cos(f2);\n    const s2 = Math.sin(f2);\n    const t = Math.tan(df / 4);\n    const hx = 4 / 3 * r1 * t;\n    const hy = 4 / 3 * r2 * t;\n    const m1 = [x1, y1];\n    const m2 = [x1 + hx * s1, y1 - hy * c1];\n    const m3 = [x2 + hx * s2, y2 - hy * c2];\n    const m4 = [x2, y2];\n    m2[0] = 2 * m1[0] - m2[0];\n    m2[1] = 2 * m1[1] - m2[1];\n    if (recursive) {\n        return [m2, m3, m4].concat(params);\n    }\n    else {\n        params = [m2, m3, m4].concat(params);\n        const curves = [];\n        for (let i = 0; i < params.length; i += 3) {\n            const r1 = rotate(params[i][0], params[i][1], angleRad);\n            const r2 = rotate(params[i + 1][0], params[i + 1][1], angleRad);\n            const r3 = rotate(params[i + 2][0], params[i + 2][1], angleRad);\n            curves.push([r1[0], r1[1], r2[0], r2[1], r3[0], r3[1]]);\n        }\n        return curves;\n    }\n}\n","import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    if (!o.disableMultiStroke) {\n        const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        o1 = o1.concat(o2);\n    }\n    return { type: 'path', ops: o1 };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                const ro = 1 * (o.maxRandomnessOffset || 0);\n                const pv = o.preserveVertices;\n                ops.push({ op: 'move', data: data.map((d) => d + (pv ? 0 : _offsetOpt(ro, o))) });\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygons(polygonList, o) {\n    return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n","function clone(p) {\n    return [...p];\n}\nexport function curveToBezier(pointsIn, curveTightness = 0) {\n    const len = pointsIn.length;\n    if (len < 3) {\n        throw new Error('A curve must have at least three points.');\n    }\n    const out = [];\n    if (len === 3) {\n        out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));\n    }\n    else {\n        const points = [];\n        points.push(pointsIn[0], pointsIn[0]);\n        for (let i = 1; i < pointsIn.length; i++) {\n            points.push(pointsIn[i]);\n            if (i === (pointsIn.length - 1)) {\n                points.push(pointsIn[i]);\n            }\n        }\n        const b = [];\n        const s = 1 - curveTightness;\n        out.push(clone(points[0]));\n        for (let i = 1; (i + 2) < points.length; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            out.push(b[1], b[2], b[3]);\n        }\n    }\n    return out;\n}\n","// distance between 2 points\nfunction distance(p1, p2) {\n    return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n    const l2 = distanceSq(v, w);\n    if (l2 === 0) {\n        return distanceSq(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = distance(outPoints[outPoints.length - 1], p0);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\nexport function simplify(points, distance) {\n    return simplifyPoints(points, 0, points.length, distance);\n}\n// Ramer–Douglas–Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n    const outPoints = newPoints || [];\n    // find the most distance point from the endpoints\n    const s = points[start];\n    const e = points[end - 1];\n    let maxDistSq = 0;\n    let maxNdx = 1;\n    for (let i = start + 1; i < end - 1; ++i) {\n        const distSq = distanceToSegmentSq(points[i], s, e);\n        if (distSq > maxDistSq) {\n            maxDistSq = distSq;\n            maxNdx = i;\n        }\n    }\n    // if that point is too far, split\n    if (Math.sqrt(maxDistSq) > epsilon) {\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n    }\n    else {\n        if (!outPoints.length) {\n            outPoints.push(s);\n        }\n        outPoints.push(e);\n    }\n    return outPoints;\n}\nexport function pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    if (distance && distance > 0) {\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\n    }\n    return newPoints;\n}\n","import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS && points.length >= 3) {\n            const bcurve = curveToBezier(points);\n            const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([polyPoints], o));\n            }\n            else {\n                paths.push(patternFillPolygons([polyPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(sets, o));\n            }\n            else {\n                paths.push(patternFillPolygons(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(svgPath(d, o));\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n}\n","import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n    const segments = parsePath(path);\n    const normalized = normalize(absolutize(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = simplify(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n","import { RoughGenerator } from './generator';\nexport class RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    if (o.strokeLineDash) {\n                        ctx.setLineDash(o.strokeLineDash);\n                    }\n                    if (o.strokeLineDashOffset) {\n                        ctx.lineDashOffset = o.strokeLineDashOffset;\n                    }\n                    this._drawToContext(ctx, drawing, precision);\n                    ctx.restore();\n                    break;\n                case 'fillPath': {\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    const fillRule = (drawable.shape === 'curve' || drawable.shape === 'polygon' || drawable.shape === 'path') ? 'evenodd' : 'nonzero';\n                    this._drawToContext(ctx, drawing, precision, fillRule);\n                    ctx.restore();\n                    break;\n                }\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n            }\n        }\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        if (o.fillLineDash) {\n            ctx.setLineDash(o.fillLineDash);\n        }\n        if (o.fillLineDashOffset) {\n            ctx.lineDashOffset = o.fillLineDashOffset;\n        }\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing, o.fixedDecimalPlaceDigits);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing, fixedDecimals, rule = 'nonzero') {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill(rule);\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n","export const SVGNS = 'http://www.w3.org/2000/svg';\n","import { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nexport class RoughSVG {\n    constructor(svg, config) {\n        this.svg = svg;\n        this.gen = new RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || window.document;\n        const g = doc.createElementNS(SVGNS, 'g');\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', o.stroke);\n                    path.setAttribute('stroke-width', o.strokeWidth + '');\n                    path.setAttribute('fill', 'none');\n                    if (o.strokeLineDash) {\n                        path.setAttribute('stroke-dasharray', o.strokeLineDash.join(' ').trim());\n                    }\n                    if (o.strokeLineDashOffset) {\n                        path.setAttribute('stroke-dashoffset', `${o.strokeLineDashOffset}`);\n                    }\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', 'none');\n                    path.setAttribute('stroke-width', '0');\n                    path.setAttribute('fill', o.fill || '');\n                    if (drawable.shape === 'curve' || drawable.shape === 'polygon') {\n                        path.setAttribute('fill-rule', 'evenodd');\n                    }\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS(SVGNS, 'path');\n        path.setAttribute('d', this.opsToPath(drawing, o.fixedDecimalPlaceDigits));\n        path.setAttribute('stroke', o.fill || '');\n        path.setAttribute('stroke-width', fweight + '');\n        path.setAttribute('fill', 'none');\n        if (o.fillLineDash) {\n            path.setAttribute('stroke-dasharray', o.fillLineDash.join(' ').trim());\n        }\n        if (o.fillLineDashOffset) {\n            path.setAttribute('stroke-dashoffset', `${o.fillLineDashOffset}`);\n        }\n        return path;\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing, fixedDecimalPlaceDigits) {\n        return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n","import { RoughCanvas } from './canvas';\nimport { RoughGenerator } from './generator';\nimport { RoughSVG } from './svg';\nexport default {\n    canvas(canvas, config) {\n        return new RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        return new RoughSVG(svg, config);\n    },\n    generator(config) {\n        return new RoughGenerator(config);\n    },\n    newSeed() {\n        return RoughGenerator.newSeed();\n    },\n};\n","import { urlAlphabet } from './url-alphabet/index.js'\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","\n<script>\n\n  import { onDestroy, afterUpdate } from 'svelte'\n  export let x\n  export let y\n  export let name\n  export let color\n  export let content\n  export let cancel\n\n  function clickOutside(node) {\n    const handleClick = (event) => {\n      if (!node.contains(event.target)) {\n\tnode.dispatchEvent(new CustomEvent(\"outclick\"));\n      }\n    }\n    document.addEventListener(\"click\", handleClick)\n    return {\n      destroy() {\n\tdocument.removeEventListener(\"click\", handleClick)\n      }\n    }\n  }\n\n  let menu\n  afterUpdate(() => {\n    const rect = menu.getBoundingClientRect()\n    const width = document.documentElement.clientWidth\n    const height = document.documentElement.clientHeight\n    if (rect.left + rect.width > width) {\n      menu.style.left = `${width - rect.width - 4}px`\n    }\n    if (rect.top + rect.height > height) {\n      menu.style.top = `${height - rect.height - 4}px`\n    }\n  })\n</script>\n\n<div class=\"background\" on:click={cancel}>\n  <div class=\"menu\" style:--position-x={x} style:--position-y={y} bind:this={menu}>\n    <div class=\"title\" style:--color={color}>{name}</div>\n    {#each content as entry}\n      {#if entry.type === 'option'}\n        <div class=\"option\" on:click={entry.fun}>{@html entry.name}</div>\n      {:else if entry.type === 'unavailable'}\n        <div class=\"unavailable\">{@html entry.name}</div>\n      {:else if entry.type === 'separator'}\n        <div class=\"separator\" />\n      {/if}\n    {/each}\n  </div>\n</div>\n  \n<style>\n  div.background {\n    position: fixed;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    z-index: 50;\n  }\n  \n  div.menu {\n    position: fixed;\n    left: calc(var(--position-x) * 1px);\n    top: calc(var(--position-y) * 1px);\n    z-index: 100;\n    background-color: white;\n    border: 1px solid black;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n  }\n\n  div.title {\n    padding: 4px 8px;\n    cursor: pointer;\n    flex: 1;\n    width: calc(100% - 16px);\n    text-align: center;\n    text-transform: uppercase;\n    font-weight: bold;\n    color: white;\n    background-color: var(--color);\n  }\n\n  div.separator {\n    flex: 1;\n    height: 1px;\n    width: 100%;\n    border-top: 1px solid black;\n  }\n\n  div.option {\n    padding: 4px 8px;\n    cursor: pointer;\n    flex: 1;\n    width: calc(100% - 16px);\n    text-align: left;\n    white-space: nowrap;\n  }\n\n  div.unavailable {\n    opacity: 0.5;\n    padding: 4px 8px;\n    flex: 1;\n    width: calc(100% - 16px);\n    text-align: left;\n    white-space: nowrap;\n  }\n\n  div.option:hover {\n    background-color: black;\n    color: white;\n  }\n\n</style>\n","\n<script>\n\n  import Menu from './Menu.svelte'\n  import { onDestroy } from 'svelte'\n  export let x\n  export let y\n  export let cancel\n  export let makeObject\n  export let updateText\n\n  const options = [\n    {\n      type: 'option',\n      fun: () => makeObject('rectangle', text),\n      name: 'Rectangle'\n    },\n    {\n      type: 'option',\n      fun: () => makeObject('ellipse', text),\n      name: 'Ellipse'\n    },\n    {\n      type: 'option',\n      fun: () => makeObject('circle', text),\n      name: 'Circle'\n    },\n    {\n      type: 'option',\n      fun: () => makeObject('line', text),\n      name: 'Line'\n    },\n    {\n      type: 'option',\n      fun: () => makeObject('arrow', text),\n      name: 'Arrow'\n    },\n    {\n      type: 'option',\n      fun: () => makeObject('reverse-arrow', text),\n      name: 'R-Arrow'\n    },\n    {\n      type: 'option',\n      fun: () => makeObject('double-arrow', text),\n      name: 'D-Arrow'\n    },\n    {\n      type: 'option',\n      fun: () => makeObject('text', text),\n      name: 'Text'\n    },\n    // {\n    //   type: 'separator'\n    // },\n    // {\n    //   type: 'option',\n    //   fun: cancel,\n    //   name: 'Cancel'\n    // },\n  ]\n\n  let chars = []\n  let text = ''\n\n  function handleKey(evt){\n    evt.preventDefault()\n    if (evt.key.length == 1 || (evt.key.length > 1 && /[^a-zA-Z0-9]/.test(evt.key))) {\n      chars.push(evt.key)\n      text = chars.join('')\n      updateText(text)\n    } else if (evt.key === 'Spacebar') {\n      chars.push(' ')\n      text = chars.join('')\n      updateText(text)\n    } else if (evt.key === 'Backspace') {\n      chars.pop()\n      text = chars.join('')\n      updateText(text)\n    } else if (evt.key === 'Escape') {\n      cancel()\n    }\n  }\n\n  document.addEventListener('keydown', handleKey)\n\n  onDestroy(() => { document.removeEventListener('keydown', handleKey) })\n  \n</script>\n\n<Menu\n  x={x}\n  y={y}\n  content={options}\n  name='Create'\n  color='red'\n  cancel={cancel}\n  />\n","\n<script>\n\n  import { onDestroy } from 'svelte'\n  import Menu from './Menu.svelte'\n  \n  export let x\n  export let y\n  export let obj\n  export let updateObject\n  export let moveObject\n  export let deleteObject\n  export let resizeObject\n  export let cancel\n  export let updateText\n\n  let options = [\n    {\n      name: 'Move',\n      type: 'option',\n      fun: move\n    },\n    {\n      name: 'Resize',\n      type: 'option',\n      fun: resize\n    },\n    {\n      name: 'Delete',\n      type: 'option',\n      fun: del\n    },\n    {\n      name: 'Forward',\n      type: 'unavailable'\n    },\n    {\n      name: 'Back',\n      type: 'unavailable'\n    },\n    {\n      type: 'separator'\n    },\n    {\n      type: 'option',\n      name: '&rarr; Rectangle',\n      fun: () => changeType('rectangle')\n    },\n    {\n      type: 'option',\n      name: '&rarr; Ellipse',\n      fun: () => changeType('ellipse')\n    },\n    {\n      type: 'option',\n      name: '&rarr; Circle',\n      fun: () => changeType('circle')\n    },\n    {\n      type: 'option',\n      name: '&rarr; Line',\n      fun: () => changeType('line')\n    },\n    {\n      type: 'option',\n      name: '&rarr; Arrow',\n      fun: () => changeType('arrow')\n    },\n    {\n      type: 'option',\n      name: '&rarr; R-Arrow',\n      fun: () => changeType('reverse-arrow')\n    },\n    {\n      type: 'option',\n      name: '&rarr; D-Arrow',\n      fun: () => changeType('double-arrow')\n    },\n    {\n      type: 'option',\n      name: '&rarr; Text',\n      fun: () => changeType('text')\n    },\n    // {\n    //   type: 'separator'\n    // },\n    // {\n    //   type: 'option',\n    //   name: 'Cancel',\n    //   fun: cancel\n    // }\n  ]\n\n  function changeType(newType) {\n    ///console.log('object = ', obj)\n    obj.type = newType\n    obj.edited = true\n    updateObject(obj)\n    ///console.log('object = ', obj)\n  }\n\n  function move(evt) {\n    moveObject(obj, evt.clientX, evt.clientY)\n  }\n\n  function del(evt) {\n    deleteObject(obj, evt.clientX, evt.clientY)\n  }\n\n  function resize(evt) {\n    resizeObject(obj, evt.clientX, evt.clientY)\n  }\n\n  let chars = [...obj.text]\n  let text = obj.text\n\n  function handleKey(evt){\n    evt.preventDefault()\n    if (evt.key.length == 1 || (evt.key.length > 1 && /[^a-zA-Z0-9]/.test(evt.key))) {\n      chars.push(evt.key)\n      text = chars.join('')\n      updateText(obj, text)\n    } else if (evt.key === 'Spacebar') {\n      chars.push(' ')\n      text = chars.join('')\n      updateText(obj, text)\n    } else if (evt.key === 'Backspace') {\n      chars.pop()\n      text = chars.join('')\n      updateText(obj, text)\n    } else if (evt.key === 'Escape') {\n      cancel()\n    }\n  }\n\n  document.addEventListener('keydown', handleKey)\n\n  onDestroy(() => { document.removeEventListener('keydown', handleKey) })\n  \n</script>\n\n<Menu\n  content={options}\n  color='blue'\n  x={x} y={y}\n  cancel={cancel}\n  name='Edit'\n  />\n","<script>\n  \n  // Interesting font to use:\n  // https://fonts.google.com/specimen/Nothing+You+Could+Do?category=Handwriting&preview.text=Server&preview.text_type=custom\n\n  import {afterUpdate} from 'svelte'\n  \n  export let roughSvg\n  export let obj\n\n  let gNode = null\n  \n  const xmlns = \"http://www.w3.org/2000/svg\"\n\n  function interceptRadius(cxy, oxy, r) {\n    const dx = cxy[0] - oxy[0]\n    const dy = cxy[1] - oxy[1]\n    const angle = Math.atan2(dy, dx)\n    const ddx = Math.cos(angle) * r\n    const ddy = Math.sin(angle) * r\n    return [cxy[0] - ddx, cxy[1] - ddy]\n  }\n\n  function rotateAbout(pxy, cxy, r) {\n    const x = pxy[0] - cxy[0]\n    const y = pxy[1] - cxy[1]\n    const nx = Math.cos(r) * x - Math.sin(r) * y\n    const ny = Math.sin(r) * x + Math.cos(r) * y\n    return [nx + cxy[0], ny + cxy[1]]\n  }\n\n  function arrowHead(end, start, target) {\n    const endX = end[0]\n    const endY = end[1]\n    const startX = start[0]\n    const startY = start[1]\n    const width = Math.abs(endX - startX)\n    const height = Math.abs(endY - startY)\n    const len = Math.min(Math.sqrt(width * width + height * height) / 2, 20)\n    const inter = interceptRadius(end, start, len)\n    const p1 = rotateAbout(inter, end, Math.PI / 6)\n    const p2 = rotateAbout(inter, end, -Math.PI / 6)\n    const r1 = roughSvg.line(endX, endY, p1[0], p1[1])\n    const r2 = roughSvg.line(endX, endY, p2[0], p2[1])\n    target.appendChild(r1)\n    target.appendChild(r2)\n  }\n\n  function createText(cxy, txt, target) {\n    // First draw the text in white with a thick pen (background).\n    const rtback = document.createElementNS(xmlns, 'text')\n    ///rtback.classSet.add('background')\n    rtback.setAttribute('x', cxy[0])\n    rtback.setAttribute('y', cxy[1])\n    rtback.setAttribute('dy', '0.35em')\n    rtback.setAttribute('text-anchor', 'middle')\n    rtback.setAttribute('font-size', '36px')\n    rtback.setAttribute('stroke-width', '10px')\n    rtback.setAttribute('stroke', 'white')\n    rtback.textContent = txt\n    target.appendChild(rtback)\n    // Then draw the actual text in the space created.\n    const rt = document.createElementNS(xmlns, 'text')\n    ///rtback.classSet.add('foreground')\n    rt.setAttribute('x', cxy[0])\n    rt.setAttribute('y', cxy[1])\n    rt.setAttribute('dy', '0.35em')\n    rt.setAttribute('text-anchor', 'middle')\n    rt.setAttribute('font-size', '36px')\n    rt.textContent = txt\n    target.appendChild(rt)\n  }\n\n  function drawObject(obj, target) {\n    const width = Math.abs(obj.box[2] - obj.box[0])\n    const height = Math.abs(obj.box[3] - obj.box[1])\n    const left = Math.min(obj.box[0], obj.box[2])\n    const top = Math.min(obj.box[1], obj.box[3])\n    switch (obj.type) {\n    case 'rectangle':\n      // Set fill to white or something...\n      const rr = roughSvg.rectangle(left, top, width, height)\n      target.appendChild(rr)\n      break\n    case 'circle':\n      const rc = roughSvg.circle((obj.box[2] + obj.box[0]) / 2, (obj.box[3] + obj.box[1]) / 2, Math.min(height, width))\n      target.appendChild(rc)\n      break\n    case 'ellipse':\n      const re = roughSvg.ellipse((obj.box[2] + obj.box[0]) / 2, (obj.box[3] + obj.box[1]) / 2, width, height)\n      target.appendChild(re)\n      break\n    case 'line':\n      const rl = roughSvg.line(obj.box[0], obj.box[1], obj.box[2], obj.box[3])\n      target.appendChild(rl)\n      break\n    case 'arrow':\n      const ra = roughSvg.line(obj.box[0], obj.box[1], obj.box[2], obj.box[3])\n      target.appendChild(ra)\n      arrowHead([obj.box[2], obj.box[3]], [obj.box[0], obj.box[1]], target)\n      break;\n    case 'reverse-arrow':\n      const rra = roughSvg.line(obj.box[0], obj.box[1], obj.box[2], obj.box[3])\n      target.appendChild(rra)\n      arrowHead([obj.box[0], obj.box[1]], [obj.box[2], obj.box[3]], target)\n      break;\n    case 'double-arrow':\n      const rda = roughSvg.line(obj.box[0], obj.box[1], obj.box[2], obj.box[3])\n      target.appendChild(rda)\n      arrowHead([obj.box[2], obj.box[3]], [obj.box[0], obj.box[1]], target)\n      arrowHead([obj.box[0], obj.box[1]], [obj.box[2], obj.box[3]], target)\n      break;\n    case 'text':\n      break\n    }\n    createText([(obj.box[0] + obj.box[2]) / 2, (obj.box[1] + obj.box[3]) / 2], obj.text, target)\n  }\n\n  function clearChildren() {\n    if (gNode) { \n      while (gNode.firstChild) {\n        gNode.removeChild(gNode.firstChild)\n      }\n    }\n  }\n\n  function action(node, obj) {\n    gNode = node\n    drawObject(obj, node)\n    return {\n      destroy() {\n        node.remove()\n      }\n    }\n  }\n\n  afterUpdate(() => {\n    if (obj.edited) { \n      delete obj.edited\n      clearChildren()\n      drawObject(obj, gNode)\n    } else if (obj.editedText) {\n      // Reach directly into the object and update the text.\n      gNode.querySelectorAll('text').forEach(n => {\n        n.textContent = obj.text\n      })\n    }\n  })\n  \n</script>\n\n<g use:action={obj} />\n\n<style>\n</style>\n","\nconst xmlns = \"http://www.w3.org/2000/svg\"\n\nexport class Guides {\n  constructor(svgNode, x, y) {\n    this._drawer = document.createElementNS(xmlns, 'g')\n    svgNode.appendChild(this._drawer)\n    this._startX = x\n    this._startY = y\n    this._endX = x\n    this._endY = y\n    const rect = document.createElementNS(xmlns, 'rect')\n    this._drawer.appendChild(rect)\n    rect.setAttribute('id', 'rect')\n    rect.setAttribute('x', this._startX)\n    rect.setAttribute('y', this._startY)\n    rect.setAttribute('width', 0)\n    rect.setAttribute('height', 0)\n    rect.setAttribute('stroke', '#ff3e00')\n    rect.setAttribute('stroke-dasharray', '5 10')\n    rect.setAttribute('fill', 'none')\n    const line1 = document.createElementNS(xmlns, 'line')\n    this._drawer.appendChild(line1)\n    line1.setAttribute('id', 'line1')\n    line1.setAttribute('x1', this._startX)\n    line1.setAttribute('y1', this._startY)\n    line1.setAttribute('x2', this._startX)\n    line1.setAttribute('y2', this._startY)\n    line1.setAttribute('stroke', '#ff3e00')\n    line1.setAttribute('stroke-dasharray', '5 10')\n    line1.setAttribute('fill', 'none')\n    const line2 = document.createElementNS(xmlns, 'line')\n    this._drawer.appendChild(line2)\n    line2.setAttribute('id', 'line2')\n    line2.setAttribute('x1', this._startX)\n    line2.setAttribute('y1', this._startY)\n    line2.setAttribute('x2', this._startX)\n    line2.setAttribute('y2', this._startY)\n    line2.setAttribute('stroke', '#ff3e00')\n    line2.setAttribute('stroke-dasharray', '5 10')\n    line2.setAttribute('fill', 'none')\n    const line3 = document.createElementNS(xmlns, 'line')\n    this._drawer.appendChild(line3)\n    line3.setAttribute('id', 'line3')\n    line3.setAttribute('x1', this._startX)\n    line3.setAttribute('y1', this._startY)\n    line3.setAttribute('x2', this._startX)\n    line3.setAttribute('y2', this._startY)\n    line3.setAttribute('stroke', '#ff3e00')\n    line3.setAttribute('stroke-dasharray', '5 10')\n    line3.setAttribute('fill', 'none')\n    const text = document.createElementNS(xmlns, 'text')\n    this._drawer.appendChild(text)\n    text.setAttribute('id', 'text')\n    text.setAttribute('x', this._startX)\n    text.setAttribute('y', this._startY)\n    text.setAttribute('dy', '0.35em')\n    text.setAttribute('text-anchor', 'middle')\n    text.setAttribute('font-size', '36px')\n    text.setAttribute('stroke', '#ff3e00')\n    text.setAttribute('opacity', '0.5')\n  }\n\n  box() {\n    return [this._startX, this._startY, this._endX, this._endY]\n  }\n  \n  resize(tx, ty) {\n    this.move(this._startX, this._startY, tx, ty)\n  }\n\n  move(sx, sy, tx, ty) {\n    // Find top-left corner.\n    this._startX = sx\n    this._startY = sy\n    this._endX = tx\n    this._endY = ty\n    const tlx = Math.min(sx, tx)\n    const tly = Math.min(sy, ty)\n    // Find width and height.\n    const width = Math.abs(tx - sx)\n    const height = Math.abs(ty - sy)\n    const rect = document.getElementById('rect')\n    rect.setAttribute('x', tlx)\n    rect.setAttribute('y', tly)\n    rect.setAttribute('width', width)\n    rect.setAttribute('height', height)\n    const line1 = document.getElementById('line1')\n    const line2 = document.getElementById('line2')\n    const line3 = document.getElementById('line3')\n    if (width < height) {\n      const margin = (height - width) / 2\n      line1.setAttribute('x1', tlx)\n      line1.setAttribute('y1', tly + margin)\n      line1.setAttribute('x2', tlx + width)\n      line1.setAttribute('y2', tly + margin)\n      line2.setAttribute('x1', tlx)\n      line2.setAttribute('y1', tly + margin + width)\n      line2.setAttribute('x2', tlx + width)\n      line2.setAttribute('y2', tly + margin + width)\n    } else if (width > height) { \n      const margin = (width - height) / 2\n      line1.setAttribute('x1', tlx + margin)\n      line1.setAttribute('y1', tly)\n      line1.setAttribute('x2', tlx + margin)\n      line1.setAttribute('y2', tly + height)\n      line2.setAttribute('x1', tlx + margin + height)\n      line2.setAttribute('y1', tly)\n      line2.setAttribute('x2', tlx + margin + height)\n      line2.setAttribute('y2', tly + height)\n    }\n    line3.setAttribute('x1', sx)\n    line3.setAttribute('y1', sy)\n    line3.setAttribute('x2', tx)\n    line3.setAttribute('y2', ty)\n    const text = document.getElementById('text')\n    text.setAttribute('x', (sx + tx) / 2)\n    text.setAttribute('y', (sy + ty) / 2)\n  }\n\n  updateText(str) {\n    const text = document.getElementById('text')\n    text.textContent = str\n  }\n\n/*\n// This is the kind of code that will split a string over multiple\n// text nodes if it is too wide.\n// I probably need to replace the single text node about with <g>,\n// and make sure that the (x,y) we have is the center node of the\n// whole set of lines, both horizontally (easy) and vertically (harder).\n\nfunction labelTopAutoSplit (svg,x,y,width,font,label) {\nlet g = svg.append(\"g\");\nlet words = label.split(/\\s+/).reverse(),\nword,\nline = [],\ndy = 0.35,\nlineNumber = 0,\nlineHeight = 1.1;  // ems\nlet text = g.append(\"text\")\n.attr(\"x\", x)\n.attr(\"y\", y)\n.attr(\"dy\", dy + \"em\")\n.attr(\"text-anchor\",\"middle\")\n.call(fontAttrs,font);\nwhile (word = words.pop()) {\nline.push(word);\ntext.text(line.join(\" \"));\nif (text.node().getComputedTextLength() > width && line.length > 1) {\n// if the line length is > allotted width, drop the last word added\n// unless that word is the only word in the line\nline.pop();\ntext.text(line.join(\" \"));\nline = [word];\ntext = g.append(\"text\")\n.attr(\"x\", x)\n.attr(\"y\", y)\n.attr(\"dy\", ++lineNumber * lineHeight + dy + \"em\")\n.attr(\"text-anchor\",\"middle\")\n.call(fontAttrs,font)\n.text(word);\n}\n}\n}\n*/\n\n  remove() {\n    while (this._drawer.firstChild) {\n      this._drawer.firstChild.remove()\n    }\n    this._drawer.remove()\n  }\n}\n\n","\nconst xmlns = \"http://www.w3.org/2000/svg\"\n\n\nfunction inObject(x, y, obj) {\n  // TODO: maintain the invariant that [0,1] is always TL and [2,3] always BR?\n  const minX = Math.min(obj.box[0], obj.box[2])\n  const maxX = Math.max(obj.box[0], obj.box[2])\n  const minY = Math.min(obj.box[1], obj.box[3])\n  const maxY = Math.max(obj.box[1], obj.box[3])\n  return x >= minX && x <= maxX && y >= minY && y <= maxY\n}\n\nfunction findObject(objects, x, y) {\n  for (let i = objects.length - 1; i >= 0; i--) {\n    if (inObject(x, y, objects[i])) {\n      return objects[i]\n    }\n  }\n  return null\n}\n\nexport class Selector {\n  constructor(svgNode) {\n    this._node = svgNode\n    this._hover = null\n    this._object = null\n  }\n\n  isSelected() {\n    return !!this._object\n  }\n\n  select(objects, pX, pY) {\n    const obj = findObject(objects, pX, pY)\n    this.selectObject(obj)\n  }\n\n  selectObject(obj) {\n    if (this._object) {\n      if (obj) {\n        if (this._object.id !== obj.id) {\n          this.clear()\n          this._select(obj)\n        }\n      } else {\n        this.clear()\n      }\n    } else {\n      if (obj) {\n        this._select(obj)\n      }\n    }\n  }\n\n  _select(obj) {\n    this._object = obj\n    this._hover = document.createElementNS(xmlns, 'rect')\n    this._node.appendChild(this._hover)\n    const box = obj.box\n    const minX = Math.min(box[0], box[2])\n    const maxX = Math.max(box[0], box[2])\n    const minY = Math.min(box[1], box[3])\n    const maxY = Math.max(box[1], box[3])\n    ///this._hover.setAttribute('id', 'hovering')\n    this._hover.setAttribute('x', minX - 5)\n    this._hover.setAttribute('y', minY - 5)\n    this._hover.setAttribute('width', maxX - minX + 10)\n    this._hover.setAttribute('height', maxY - minY + 10)\n    // this._hover.setAttribute('x', 0)\n    // this._hover.setAttribute('y', 0)\n    // this._hover.setAttribute('width', 0)\n    // this._hover.setAttribute('height', 0)\n    this._hover.setAttribute('stroke', '#003eff')\n    this._hover.setAttribute('stroke-dasharray', '5 10')\n    this._hover.setAttribute('fill', 'none')\n  }\n\n  object() {\n    return this._object\n  }\n\n  clear() {\n    if (this.isSelected()) { \n      this._hover.remove()\n      this._hover = null\n      this._object = null\n    }\n  }\n}\n\n\n  \n","<script>\n\n  // How to draw:\n  // https://stackoverflow.com/questions/2368784/draw-on-html5-canvas-using-a-mouse\n\n  // TODO: assign a unique ID to each object in the diagram.\n\n  import rough from \"roughjs/bin/rough\"\n  import { nanoid } from 'nanoid'\n  import MenuCreate from \"./MenuCreate.svelte\"\n  import MenuEdit from \"./MenuEdit.svelte\"\n  import Object from \"./Object.svelte\"\n  import { Guides } from './guides.js'\n  import { Selector } from './selector.js'\n\n  let roughSvg\n  let svgNode\n  let svgX\n  let svgY\n  export let objects\n  export let addObject\n  export let deleteObject\n\n  // How many pixels' fuzz do we allow we recognizing that we're creating\n  // an object as opposed to click on an existing object.\n  const fuzz = 4\n  \n  const xmlns = \"http://www.w3.org/2000/svg\"\n\n  // TODO: Concept of a mode: creating, moving, resizing, ...\n  \n  let selector\n  let startX\n  let startY\n  let endX\n  let endY\n  let guides = null       // Gets a value when drawing\n  let showMenuCreate\n  let showMenuEdit\n  let moving = false\n  let resizing = false\n\n  function isShowMenu() {\n    return showMenuCreate || showMenuEdit\n  }\n\n  function updateGuidesText(str) {\n    guides.updateText(str)\n  }\n\n  function updateObjectText(obj, str) {\n    // Note that this makes the object \"redraw\" itself so it looks like it wiggles around as you type.\n    obj.text = str\n    obj.editedText = true\n    addObject()\n  }\n\n  function clearGuides() {\n    if (guides) { \n      guides.remove()\n      guides = null\n    }\n  }\n\n  function handleMouseDown(evt) {\n    if (evt.button == 0) {\n      // Left button press.\n      if (!showMenuCreate && !showMenuEdit && !moving && !resizing) {\n        startX = evt.clientX - svgX\n        startY = evt.clientY - svgY\n        guides = new Guides(svgNode, startX, startY)\n      }\n    }\n  }\n\n  function handleMenuCancel() {\n    clearGuides()\n    showMenuCreate = false\n    showMenuEdit = false\n  }\n\n  function handleMenuObject(typ, txt) {\n    clearGuides()\n    const obj = {\n      id: nanoid(),\n      type: typ,\n      box: [startX, startY, endX, endY],\n      text: txt\n    }\n    addObject(obj)\n    showMenuCreate = false\n  }\n\n  function handleMenuUpdate(obj) {\n    // Adding a null object is just a refresh.\n    addObject()\n    showMenuEdit = false\n  }\n\n  function handleMenuMove(obj, clientX, clientY) {\n    const guides = new Guides(svgNode, obj.box[0], obj.box[1])\n    guides.resize(obj.box[2], obj.box[3])\n    startX = clientX - svgX\n    startY = clientY - svgY\n    moving = [obj, guides]\n    showMenuEdit = false\n  }\n\n  function handleMenuResize(obj, clientX, clientY) {\n    const guides = new Guides(svgNode, obj.box[0], obj.box[1])\n    startX = obj.box[0]\n    startY = obj.box[1]\n    endX = clientX - svgX\n    endY = clientY - svgY\n    guides.resize(endX, endY)\n    resizing = [obj, guides]\n    showMenuEdit = false\n  }\n\n  function handleMenuDelete(obj, clientX, clientY) {\n    deleteObject(obj)\n    // Adjustment because we are affecting the resulting hovering.\n    selector.clear()\n    const pX = clientX - svgX\n    const pY = clientY - svgY\n    selector.select(objects, pX, pY)\n    showMenuEdit = false\n  }\n\n  function handleMouseUp(evt) {\n    if (showMenuCreate || showMenuEdit) {\n      return\n    }\n    endX = evt.clientX - svgX\n    endY = evt.clientY - svgY\n    if (evt.button == 0) {\n      // Left button release.\n      if (guides) {\n        if (Math.abs(startX - endX) > fuzz || Math.abs(startY - endY) > fuzz) {\n          showMenuCreate = [endX, endY]\n        } else {\n          clearGuides()\n          // Show edit menu if we have a selected object.\n          if (selector.isSelected()) {\n            //console.log('object = ', hovering)\n            showMenuEdit = [endX, endY, selector.object()]\n          }\n        }\n      } else if (moving) {\n        const [obj, guides ] = moving\n        guides.remove()\n        moving = false\n        obj.box = guides.box()\n        obj.edited = true\n        addObject()\n        // Adjustment because we are affecting the resulting hovering.\n        selector.clear()\n        selector.select(objects, endX, endY)\n      } else if (resizing) {\n        const [obj, guides ] = resizing\n        guides.remove()\n        resizing = false\n        obj.box = guides.box()\n        obj.edited = true\n        addObject()\n        // Adjustment because we are affecting the resulting hovering.\n        selector.clear()\n        selector.select(objects, endX, endY)\n      }\n    } else if (evt.button == 2) {\n      // Right button click.\n      if (!guides) {\n        if (selector.isSelected()) {\n          // We have a selected object!\n          console.log('selected = ', selector.object())\n        }\n      }\n    }\n  }\n\n  function handleMouseMove(evt) {\n    if (showMenuCreate || showMenuEdit) {\n      return\n    }\n    const endX = evt.clientX - svgX\n    const endY = evt.clientY - svgY\n    if (guides) {\n      guides.resize(endX, endY)\n    } else if (moving) {\n      const dx = endX - startX\n      const dy = endY - startY\n      const [obj, guides] = moving\n      guides.move(obj.box[0] + dx, obj.box[1] + dy, obj.box[2] + dx, obj.box[3] + dy)\n    } else if (resizing) {\n      const [obj, guides] = resizing\n      guides.resize(endX, endY)\n    }\n    selector.select(objects, endX, endY)\n  }\n    \n  function handleMouseOut(evt) {\n    if (guides) {\n      clearGuides()\n    }\n  }\n\n  function handleContextMenu(evt) {\n    evt.preventDefault()\n  }\n  \n  function action(node) {\n    svgNode = node\n    const rect = node.getBoundingClientRect()\n    svgX = rect.left\n    svgY = rect.top\n    roughSvg = rough.svg(node)\n    selector = new Selector(node)\n  }\n\n</script>\n\n<svg on:mousedown={handleMouseDown}\n     on:mouseup={handleMouseUp}\n     on:mousemove={handleMouseMove}\n     on:contextmenu={handleContextMenu}\n     use:action>\n  {#each objects as obj (obj.id)}\n    <Object obj={obj} roughSvg={roughSvg}/>\n  {/each}\n</svg>\n\n{#if showMenuCreate}\n  <MenuCreate\n    x={showMenuCreate[0]}\n    y={showMenuCreate[1]}\n    cancel={handleMenuCancel}\n    makeObject={handleMenuObject}\n    updateText={updateGuidesText}\n    />\n  {/if}\n\n{#if showMenuEdit}\n  <MenuEdit\n    x={showMenuEdit[0]}\n    y={showMenuEdit[1]}\n    obj={showMenuEdit[2]}\n    updateObject={handleMenuUpdate}\n    moveObject={handleMenuMove}\n    deleteObject={handleMenuDelete}\n    resizeObject={handleMenuResize}\n    updateText={updateObjectText}\n    cancel={handleMenuCancel}\n    />\n  {/if}\n\n<style>\n  svg {\n    width: calc(100vw - 16px);\n    height: calc(100vh - 16px);\n    background-color: white;\n    /* border: 1px solid #ff3e00;*/\n  }\n</style>\n","<script>\n\n  // Icons:\n  //\n  //   https://www.svgrepo.com/collection/handy-icon-collection/\n  //   https://github.com/djamshed/rough-awesome-font/\n\n\n  export let width = '2em'\n  export let src\n  export let clickFn = undefined\n  export let href = undefined\n  \n</script>\n\n{#if clickFn}\n  <img class=\"icon active\" src={src} style=\"width: {width}\" on:click={clickFn}>\n{:else if href}\n  <a href={href} target=\"_blank\"><img class=\"icon active\" src={src} style=\"width: {width}\"></a>\n{:else}\n  <img class=\"icon\" src={src} style=\"width: {width}\">\n{/if}\n  \n<style>\n  img.icon {\n    flex: 1;\n    margin: 12px 8px;\n    opacity: 0.3;\n  }\n\n  img.active {\n    cursor: pointer;\n    opacity: 1;\n  }\n\n  img.active:hover {\n    opacity: 1;\n  }\n</style>\n\n","\n<script>\n\n  import { onDestroy } from 'svelte'\n  export let name\n  export let color\n  export let cancel\n\n</script>\n\n<div class=\"background\" on:click={cancel}>\n  <div class=\"frame\" on:click|stopPropagation={() => {}}>\n    <div class=\"title\" style:--color={color}>{name}</div>\n    <slot>\n    </slot>\n  </div>\n</div>\n  \n<style>\n  div.background {\n    position: fixed;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    z-index: 50;\n  }\n\n  div.frame {\n    position: fixed;\n    left: 25vw;\n    right: 25vw;\n    top: 25vh;\n    z-index: 100;\n    background-color: white;\n    border: 1px solid black;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    background-color: white;\n  }\n\n  div.title {\n    padding: 4px;\n    cursor: pointer;\n    flex: 1;\n    width: calc(100% - 8px);\n    text-align: center;\n    text-transform: uppercase;\n    font-weight: bold;\n    color: white;\n    background-color: var(--color);\n  }\n\n</style>\n\n","<script>\n\n  import DiagramEditor from './DiagramEditor.svelte'\n  import Icon from './Icon.svelte'\n  import Dialog from './Dialog.svelte'\n\n  let objects = []\n  let d_height = 400\n  let d_width = 400\n\n  let files\n\n  const D_DISABLED = 0\n  const D_ENABLED = 1\n  const D_ERROR = 2\n  \n  let showUploadDB = D_DISABLED\n\n  $: hasObjects = objects && objects.length > 0\n\n  function clearDiagram() {\n    objects = []\n  }\n\n  function addObject(obj) {\n    if (obj) { \n      objects.push(obj)\n    }\n    objects = objects\n    ///console.log('refreshing objects = ', objects)\n  }\n\n  function deleteObject(obj) {\n    if (obj) {\n      for (let i = 0; i < objects.length; i++) {\n        if (obj.id === objects[i].id) {\n          objects.splice(i, 1)\n        }\n      }\n    }\n    objects = objects\n  }\n\n  function enableUploadDB() {\n    showUploadDB = D_ENABLED\n  }\n  \n  function uploadDiagram() {\n    // TODO: Need a modal box to get the name!\n    if (files) {\n      files[0].text().then((content) => { \n        const json = JSON.parse(content)\n        if (validate(json)) {\n          d_height = json.height\n          d_width = json.width\n          objects = json.objects\n          showUploadDB = D_DISABLED\n        } else {\n          showUploadDB = D_ERROR\n        }\n      }).catch((err) => {\n        //console.log(err)\n        showUploadDB = D_ERROR\n      })\n    }\n  }\n\n  function validate(json) {\n    // TODO: Write me!\n    return true\n  }\n  \n  function downloadDiagram() {\n    const diagram = {\n      height: d_height,\n      width: d_width,\n      objects: objects\n    }\n    const blob = new Blob([JSON.stringify(diagram, null, 2)], { type: 'text/json' })\n    const link = document.createElement('a')\n    link.download = 'diagram.json'\n    link.href = window.URL.createObjectURL(blob)\n    link.dataset.downloadurl = ['text/json', link.download, link.href].join(':')\n    const evt = new MouseEvent('click', {\n      view: window,\n      bubbles: true,\n      cancelable: true,\n    })\n    link.dispatchEvent(evt)\n    link.remove()\n  }\n\n</script>\n\n<svelte:head>\n  <title>Rough Sketch</title>\n  <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n  <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n  <link href=\"https://fonts.googleapis.com/css2?family=Nothing+You+Could+Do\" rel=\"stylesheet\">\n  <style>\n    body {\n      padding: 8px;\n      user-select: none;\n    }\n    \n    svg text {\n      font-family: Nothing You Could Do;\n      font-display: block;\n    }\n  </style>\n</svelte:head>\n\n\n<main>\n  <div class=\"title\">Rough Sketch</div>\n  <div class=\"icons\">\n    <Icon src=\"assets/icons/clear.svg\" width=\"1.5em\" clickFn={hasObjects && clearDiagram} />\n    <Icon src=\"assets/icons/upload.svg\" width=\"1.5em\" clickFn={!hasObjects && enableUploadDB} />\n    <Icon src=\"assets/icons/download.svg\" width=\"1.5em\" clickFn={hasObjects && downloadDiagram} />\n    <!-- <Icon src=\"assets/icons/help.svg\" width=\"1.5em\" /> -->\n    <!-- <Icon src=\"assets/icons/settings.svg\" width=\"1.5em\" /> -->\n    <Icon src=\"assets/icons/github.svg\" width=\"1.5em\" href=\"https://github.com/rpucella/Rough-Sketch\" />\n  </div>\n  <DiagramEditor objects={objects} addObject={addObject} deleteObject={deleteObject} />\n</main>\n\n{#if showUploadDB > 0}\n  <Dialog name=\"Upload Diagram\" color=\"blue\" cancel={() => { showUploadDB = D_DISABLED }}>\n    <div class=\"content\">\n      <div>\n        Choose a diagram to upload:\n      </div>\n        <input type=\"file\" bind:files>\n        {#if showUploadDB === D_ERROR}\n          <div class=\"error\">\n            There is a problem with the JSON file.\n          </div>\n        {/if}\n      <div>\n        {#if files}\n          <button on:click={uploadDiagram}>Upload</button>\n        {:else}\n          <button disabled>Upload</button>\n          {/if}\n      </div>\n    </div>\n    </Dialog>\n  {/if}\n<div>\n</div>\n\n<style>\n  \n  div.title {\n    position: absolute;\n    right: 8px;\n    top: 8px;\n    text-align: center;\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 3em;\n    font-weight: 100;\n  }\n\n  div.icons {\n    position: absolute;\n    top: 5em;\n    right: 8px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  div.content {\n    padding: 8px 8px;\n    width: 100%;\n    box-sizing: border-box;\n  }\n\n  div.content * {\n    margin: 8px 0;\n  }\n\n  div.content button {\n    margin-top: 16px;\n  }\n\n  div.error {\n    color: red;\n  }\n\n</style>\n\n","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {}\n});\n\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","src_url_equal_anchor","current_component","src_url_equal","element_src","url","document","createElement","href","get_slot_context","definition","ctx","$$scope","tar","src","k","assign","slice","action_destroyer","action_result","destroy","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","svg_element","createElementNS","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_data","wholeText","set_style","key","important","style","removeProperty","setProperty","set_current_component","component","get_current_component","Error","afterUpdate","$$","after_update","push","onDestroy","on_destroy","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","seen_callbacks","Set","flushidx","flush","saved_component","length","update","pop","i","callback","has","add","clear","fragment","before_update","dirty","p","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","d","globals","window","globalThis","global","outro_and_destroy_block","lookup","create_component","mount_component","customElement","on_mount","m","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","Map","callbacks","skip_bound","root","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","$destroy","this","$on","type","index","indexOf","splice","$set","$$props","obj","$$set","keys","rotatePoints","points","center","degrees","cx","cy","angle","Math","PI","cos","sin","x","y","lineLength","line","p1","p2","sqrt","pow","polygonHachureLines","polygonList","hachureAngle","gap","hachureGap","strokeWidth","max","rotationCenter","polygon","lines","vertexArray","vertices","join","edges","ymin","min","ymax","islope","sort","e1","e2","abs","activeEdges","ix","edge","s","ae","ae1","ae2","nexti","ce","ne","round","straightHachureLines","rotateLines","HachureFiller","constructor","helper","fillPolygons","_fillPolygons","ops","renderLines","doubleLineOps","ZigZagFiller","zigZagAngle","zigzagLines","dgx","dgy","HatchFiller","set","o2","set2","concat","DotFiller","dotsOnLines","fweight","fillWeight","ro","dl","count","ceil","offset","minY","random","el","ellipse","DashedFiller","dashedLine","dashOffset","dashGap","floor","startOffset","alpha","atan","lstart","lend","start","end","ZigZagLineFiller","zo","zigzagOffset","dz","middle","fillers","Random","seed","next","imul","PARAMS","A","C","H","h","L","M","Q","q","S","T","t","V","v","Z","z","isType","token","parsePath","segments","tokens","match","substr","RegExp","$1","parseFloat","tokenize","mode","paramsCount","params","numbeToken","segment","absolutize","subx","suby","out","newdata","normalize","lastType","lcx","lcy","cx1","cy1","x1","y1","cx2","cy2","r1","r2","largeArcFlag","sweepFlag","arcToCubicCurves","curve","rotate","angleRad","x2","y2","recursive","f1","f2","r1Pow","r2Pow","left","right","asin","toFixed","df","f2old","x2old","y2old","c1","s1","c2","s2","tan","hx","hy","m1","m2","m3","m4","curves","r3","randOffset","_offsetOpt","randOffsetWithRange","_offset","width","height","generateEllipseParams","ellipseWithParams","opset","_doubleLine","linearPath","close","len","rectangle","o1","_curveWithOffset","roughness","disableMultiStroke","result","randomizer","undefined","cloneOptionsAlterSeed","psq","stepCount","curveStepCount","increment","rx","ry","curveFitRandomness","curveFitting","ellipseParams","ap1","cp1","_computeEllipsePoints","_curve","ap2","estimatedPoints","arc","stop","closed","roughClosure","strt","stp","ellipseInc","arcInc","_arc","op","solidFillPolygon","maxRandomnessOffset","patternFillPolygons","fillerName","fillStyle","getFiller","roughnessGain","filling","singleStroke","disableMultiStrokeFill","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","randomHalf","randomFull","preserveVertices","ps","closePoint","curveTightness","cachedVertArray","overlap","corePoints","allPoints","radOffset","endAngle","_bezierTo","current","ros","f","iterations","clone","distanceSq","distanceToSegmentSq","w","l2","lerp","getPointsOnBezierCurveWithSplitting","tolerance","newPoints","outPoints","p3","p4","ux","uy","vx","vy","flatness","p0","q1","q2","q3","red","simplify","distance","simplifyPoints","epsilon","e","maxDistSq","maxNdx","distSq","pointsOnBezierCurves","numSegments","NOS","RoughGenerator","config","defaultOptions","stroke","_o","static","_d","shape","sets","paths","outline","ellipseResponse","circle","diameter","fillOptions","patternFillArc","bcurve","pointsIn","curveToBezier","polyPoints","path","replace","hasFill","hasStroke","simplified","simplification","normalized","currentPoints","pendingCurve","appendPendingCurve","appendPendingPoints","lastPoint","simplifiedSet","pointsOnPath","first","pv","svgPath","opsToPath","drawing","fixedDecimals","item","trim","toPaths","drawable","fillSketch","RoughCanvas","canvas","getContext","gen","draw","getDefaultOptions","precision","fixedDecimalPlaceDigits","save","strokeStyle","lineWidth","strokeLineDash","setLineDash","strokeLineDashOffset","lineDashOffset","_drawToContext","restore","fillRule","fillLineDash","fillLineDashOffset","rule","beginPath","moveTo","bezierCurveTo","lineTo","generator","SVGNS","RoughSVG","svg","doc","ownerDocument","g","rough","newSeed","nanoid","size","id","bytes","crypto","getRandomValues","Uint8Array","byte","toString","toUpperCase","div","raw_value","innerHTML","fun","apply","arguments","create_if_block","create_if_block_1","create_if_block_2","div2","div1","div0","menu","color","content","cancel","rect","getBoundingClientRect","documentElement","clientWidth","clientHeight","top","$$value","makeObject","updateText","chars","handleKey","evt","preventDefault","test","updateObject","moveObject","deleteObject","resizeObject","clientX","clientY","changeType","newType","edited","xmlns","rotateAbout","pxy","cxy","nx","ny","roughSvg","gNode","arrowHead","endX","endY","startX","startY","inter","oxy","dx","dy","atan2","ddx","ddy","interceptRadius","drawObject","box","rr","rc","re","rl","ra","rra","rda","txt","rtback","textContent","rt","createText","firstChild","clearChildren","editedText","querySelectorAll","n","remove","Guides","svgNode","_drawer","_startX","_startY","_endX","_endY","line1","line2","line3","resize","tx","ty","sx","sy","tlx","tly","getElementById","margin","str","inObject","minX","maxX","maxY","Selector","_node","_hover","_object","isSelected","select","objects","pX","pY","findObject","selectObject","_select","object","menucreate_changes","menuedit_changes","get_key","handleContextMenu","old_blocks","dynamic","list","create_each_block","get_context","old_indexes","new_blocks","new_lookup","deltas","child_ctx","get","will_move","did_move","new_block","old_block","new_key","old_key","svgX","svgY","selector","showMenuCreate","showMenuEdit","addObject","guides","moving","resizing","clearGuides","button","$$invalidate","typ","console","log","img","img_src_value","clickFn","slot_ctx","stopPropagation","call","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","lets","merged","if_block0","D_ERROR","input","if_block","document_1","head","link0","link1","link2","main","icon0_changes","icon1_changes","icon2_changes","files","d_height","d_width","showUploadDB","hasObjects","json","JSON","parse","catch","err","diagram","blob","Blob","stringify","link","download","URL","createObjectURL","dataset","downloadurl","MouseEvent","view","bubbles","cancelable","dispatchEvent","body"],"mappings":"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"}